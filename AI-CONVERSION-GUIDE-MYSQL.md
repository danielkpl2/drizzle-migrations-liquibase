# AI Migration Conversion Guide — MySQL

> **For AI models**: This file contains the complete rules and examples needed to convert
> Drizzle Kit **MySQL** migrations into Liquibase-formatted SQL. Follow these rules exactly.
> Every rule is mandatory unless explicitly marked as optional.

---

## Task

You are converting **Drizzle Kit** MySQL migration files (generated by `drizzle-kit generate`)
into **Liquibase Formatted SQL** files compatible with `drizzle-migrations-liquibase`.

**Input**: One or more Drizzle Kit `.sql` migration files (e.g. `0001_cool_name.sql`)
**Output**: Liquibase-formatted `.sql` files with rollback support
**Dialect**: MySQL — identifiers use backticks (`` `users` ``, `` `id` ``)

---

## Output File Template

Every output file MUST follow this exact structure:

```sql
--liquibase formatted sql

--changeset <author>:<changeset_id>

<statement 1>;

<statement 2>;

--rollback <rollback for statement 2>;
--rollback <rollback for statement 1>;
```

---

## Rules

### Rule 1: File Header

The **very first line** must be:
```
--liquibase formatted sql
```
No blank lines or comments before it.

### Rule 2: Changeset Declaration

After one blank line, add:
```
--changeset <author>:<changeset_id>
```

- **`<author>`**: The git email, username, or configured author name. If unknown, use `migration`.
- **`<changeset_id>`**: A **descriptive** snake_case name summarising the migration's SQL content.
  Drizzle Kit auto-generates opaque or random names (e.g. `cool_name`, `mighty_blob`, `shiny_wasp`).
  **Do NOT use these.** Instead, read the SQL statements and derive a meaningful name:
  - `0001_cool_name.sql` containing `` CREATE TABLE `users` `` → `create_users_table`
  - `0003_mighty_blob.sql` containing `` ADD `phone` `` + `` ADD `avatar_url` `` on `` `users` `` → `add_phone_and_avatar_to_users`
  - `0042_add_user_roles.sql` → `add_user_roles` (already descriptive — keep as-is)

**Do NOT add** `splitStatements:false` or `endDelimiter` — MySQL statements all terminate with `;` and have no compound blocks, so Liquibase's default splitting works correctly.

### Rule 3: Strip Drizzle Kit Statement Breakpoints

Drizzle Kit input files contain `--> statement-breakpoint` separators between statements.
**Remove these entirely** — they are not needed in the output. Liquibase splits MySQL
changesets on `;` by default, which is correct for all MySQL statements.

Separate statements with a blank line for readability.

### Rule 4: Idempotent DDL

MySQL has limited idempotent DDL support. Only transform these:

| Original | Converted |
|----------|-----------|
| `` CREATE TABLE `x` ( `` | `` CREATE TABLE IF NOT EXISTS `x` ( `` |
| `` DROP TABLE `x` `` | `` DROP TABLE IF EXISTS `x` `` |

**Leave all other MySQL DDL as-is:**
- `` ADD `column` `` — no `IF NOT EXISTS` support
- `DROP COLUMN` — no `IF EXISTS` support
- `CREATE INDEX` — no `IF NOT EXISTS` support (duplicate index errors are acceptable)
- `MODIFY COLUMN` — keep as-is

**Note**: MySQL enums are inline column types (`` enum('a','b','c') ``) within `CREATE TABLE` or `MODIFY COLUMN` — they never appear as separate `CREATE TYPE` statements. No wrapping is needed.

### Rule 5: Foreign Key Handling

MySQL foreign keys are standalone `ALTER TABLE` statements:
```sql
ALTER TABLE `orders` ADD CONSTRAINT `orders_user_id_users_id_fk` FOREIGN KEY (`user_id`) REFERENCES `users`(`id`) ON DELETE no action ON UPDATE no action;
```

**Keep as-is** — MySQL does not support PL/pgSQL blocks. Do not wrap. The statement will error if the constraint already exists, which is the expected behavior for a non-idempotent DDL.

### Rule 6: Rollback Block

After all forward statements, add rollback lines. Rules:

1. Every `--rollback` line is a SQL comment — prefix each line with `--rollback `.
2. Rollback statements are in **reverse order** of the forward statements.
3. Each rollback statement is a separate `--rollback` line ending with `;`.

#### Rollback mappings

| Forward Statement | Rollback Statement |
|-------------------|--------------------|
| `` CREATE TABLE IF NOT EXISTS `x` (...) `` | `` DROP TABLE IF EXISTS `x`; `` |
| `` DROP TABLE IF EXISTS `x` `` | `-- WARNING: Cannot rollback DROP TABLE for x` |
| `` ADD `c` <type> `` | `` ALTER TABLE `x` DROP COLUMN `c`; `` |
| `` DROP COLUMN `c` `` | `-- WARNING: Cannot rollback DROP COLUMN for x.c` |
| `` MODIFY COLUMN `c` <new_type> `` | `-- Manual rollback required: revert MODIFY COLUMN change on x.c;` |
| `` ADD CONSTRAINT `c` FOREIGN KEY (...) `` | `` ALTER TABLE `x` DROP CONSTRAINT `c`; `` |
| `` CREATE INDEX `i` ON `t` `` | `` DROP INDEX `i` ON `t`; `` |
| `` DROP INDEX `i` ON `t` `` | `-- WARNING: Cannot rollback index drop i` |
| `INSERT INTO ...` | `DELETE FROM ... WHERE ...;` (match the inserted row) |
| `UPDATE ... SET ...` | `-- WARNING: Cannot reliably rollback UPDATE` |

**MySQL rollback notes:**
- `DROP INDEX` requires `ON <table>` — e.g. `` DROP INDEX `idx` ON `users`; ``
- `DROP CONSTRAINT` does not support `IF EXISTS` — the rollback will error if the constraint doesn't exist
- `MODIFY COLUMN` rollback requires knowing the previous column definition, which isn't available from the forward migration alone — use a manual rollback comment

### Rule 7: Filename

Rename the file:
```
<timestamp>_<original_name>.sql
```

- **Timestamp**: `YYYYMMDDHHmmss` format using the current date/time. If converting a batch, increment by 1 second per file to maintain order.
- **Descriptive name**: Drizzle Kit often generates random/opaque names (`cool_name`, `mighty_blob`, `shiny_wasp`).
  **Replace these with a descriptive snake_case name** derived from the SQL content of the migration.
  If the original name is already descriptive, keep it.
  - `0001_cool_name.sql` (creates `users` table) → `20250710092120_create_users_table.sql`
  - `0003_mighty_blob.sql` (adds columns to `users`) → `20250710092122_add_phone_and_avatar_to_users.sql`
  - `0042_add_user_roles.sql` (already descriptive) → `20250710092121_add_user_roles.sql`

  **Naming heuristics** (in priority order):
  1. `` CREATE TABLE `x` `` → `create_x_table`
  2. `` ADD `column` `` on `` `x` `` → `add_<columns>_to_x`
  3. `MODIFY COLUMN` on `` `x` `` → `modify_<columns>_in_x`
  4. `` DROP TABLE `x` `` → `drop_x_table`
  5. `CREATE INDEX` / `ADD CONSTRAINT` → `add_indexes_to_x` or `add_constraints_to_x`
  6. Mixed operations → pick the most significant operation for the name
  7. If the original Drizzle Kit name is already descriptive (contains a verb + noun), keep it

### Rule 8: One Changeset Per File (Default)

Each output file should contain **one `--changeset` block** unless the input file logically groups
related operations (e.g. table creation + its indexes + its foreign keys). In that case, use one changeset
for the whole file.

**Never split a single Drizzle Kit migration across multiple output files.**

### Rule 9: Master Changelog

After converting all files, provide the `master-changelog.xml` with includes in chronological order:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<databaseChangeLog
    xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog
        http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-4.20.xsd">

    <include file="migrations/<filename1>.sql"/>
    <include file="migrations/<filename2>.sql"/>
    <!-- ... one per file, in timestamp order -->
</databaseChangeLog>
```

### Rule 10: Remove Drizzle Kit Statement Breakpoints

Drizzle Kit input files use `--> statement-breakpoint` as a statement separator.
**Remove all occurrences** from the output — Liquibase uses `;` as the default
statement delimiter for MySQL, which is sufficient.

---

## Complete Conversion Examples

### Example 1: CREATE TABLE + FK + INDEX

**Input** (`0001_initial.sql`):
```sql
CREATE TABLE `users` (
	`id` serial AUTO_INCREMENT NOT NULL,
	`email` varchar(255) NOT NULL,
	`name` varchar(100),
	`role` enum('admin','member','guest') NOT NULL DEFAULT 'member',
	`created_at` timestamp NOT NULL DEFAULT (now()),
	CONSTRAINT `users_id` PRIMARY KEY(`id`),
	CONSTRAINT `users_email_unique` UNIQUE(`email`)
);
--> statement-breakpoint
CREATE TABLE `orders` (
	`id` serial AUTO_INCREMENT NOT NULL,
	`user_id` bigint unsigned NOT NULL,
	`total_amount` decimal(10,2) NOT NULL,
	`created_at` timestamp NOT NULL DEFAULT (now()),
	CONSTRAINT `orders_id` PRIMARY KEY(`id`)
);
--> statement-breakpoint
ALTER TABLE `orders` ADD CONSTRAINT `orders_user_id_users_id_fk` FOREIGN KEY (`user_id`) REFERENCES `users`(`id`) ON DELETE no action ON UPDATE no action;
--> statement-breakpoint
CREATE INDEX `users_email_idx` ON `users` (`email`);
--> statement-breakpoint
CREATE INDEX `orders_user_id_idx` ON `orders` (`user_id`);
```

**Output** (`20250710092120_initial.sql`):
```sql
--liquibase formatted sql

--changeset migration:initial

CREATE TABLE IF NOT EXISTS `users` (
	`id` serial AUTO_INCREMENT NOT NULL,
	`email` varchar(255) NOT NULL,
	`name` varchar(100),
	`role` enum('admin','member','guest') NOT NULL DEFAULT 'member',
	`created_at` timestamp NOT NULL DEFAULT (now()),
	CONSTRAINT `users_id` PRIMARY KEY(`id`),
	CONSTRAINT `users_email_unique` UNIQUE(`email`)
);

CREATE TABLE IF NOT EXISTS `orders` (
	`id` serial AUTO_INCREMENT NOT NULL,
	`user_id` bigint unsigned NOT NULL,
	`total_amount` decimal(10,2) NOT NULL,
	`created_at` timestamp NOT NULL DEFAULT (now()),
	CONSTRAINT `orders_id` PRIMARY KEY(`id`)
);

ALTER TABLE `orders` ADD CONSTRAINT `orders_user_id_users_id_fk` FOREIGN KEY (`user_id`) REFERENCES `users`(`id`) ON DELETE no action ON UPDATE no action;

CREATE INDEX `users_email_idx` ON `users` (`email`);

CREATE INDEX `orders_user_id_idx` ON `orders` (`user_id`);

--rollback DROP INDEX `orders_user_id_idx` ON `orders`;
--rollback DROP INDEX `users_email_idx` ON `users`;
--rollback ALTER TABLE `orders` DROP CONSTRAINT `orders_user_id_users_id_fk`;
--rollback DROP TABLE IF EXISTS `orders`;
--rollback DROP TABLE IF EXISTS `users`;
```

**Key points:**
- Backtick identifiers
- `enum(...)` is inline in the column definition — no `CREATE TYPE` or wrapping
- Foreign keys are **not** wrapped in `DO $$ BEGIN ... EXCEPTION END $$`
- `DROP INDEX` requires `ON <table>` syntax
- No `IF EXISTS` / `IF NOT EXISTS` on `ADD CONSTRAINT`, `CREATE INDEX`, `ADD COLUMN`, or `DROP COLUMN`

### Example 2: ADD COLUMN + MODIFY COLUMN

**Input** (`0005_add_fields.sql`):
```sql
ALTER TABLE `orders` MODIFY COLUMN `status` enum('pending','processing','shipped','delivered','cancelled','refunded','on_hold') NOT NULL DEFAULT 'pending';
--> statement-breakpoint
ALTER TABLE `users` ADD `phone` varchar(20);
--> statement-breakpoint
ALTER TABLE `users` ADD `avatar_url` varchar(500);
--> statement-breakpoint
CREATE INDEX `products_name_status_idx` ON `products` (`name`,`status`);
```

**Output** (`20250710092121_add_fields.sql`):
```sql
--liquibase formatted sql

--changeset migration:add_fields

ALTER TABLE `orders` MODIFY COLUMN `status` enum('pending','processing','shipped','delivered','cancelled','refunded','on_hold') NOT NULL DEFAULT 'pending';

ALTER TABLE `users` ADD `phone` varchar(20);

ALTER TABLE `users` ADD `avatar_url` varchar(500);

CREATE INDEX `products_name_status_idx` ON `products` (`name`,`status`);

--rollback DROP INDEX `products_name_status_idx` ON `products`;
--rollback ALTER TABLE `users` DROP COLUMN `avatar_url`;
--rollback ALTER TABLE `users` DROP COLUMN `phone`;
--rollback -- Manual rollback required: revert MODIFY COLUMN change on orders.status;
```

**Key points:**
- MySQL uses `ADD <col>` without the `COLUMN` keyword and without `IF NOT EXISTS`
- `MODIFY COLUMN` replaces PostgreSQL's `ALTER COLUMN ... SET DATA TYPE` — rollback requires knowing the previous definition
- No `IF EXISTS` on `DROP COLUMN`

---

## Batch Conversion Checklist

When converting multiple Drizzle Kit migration files at once:

1. Sort input files by their numeric prefix (`0001`, `0002`, ...)
2. Assign incrementing timestamps to output files (maintain original order)
3. Convert each file independently using the rules above
4. Generate `master-changelog.xml` with all files in timestamp order
5. Verify: only `CREATE TABLE` / `DROP TABLE` have `IF [NOT] EXISTS`, FKs are NOT wrapped, `DROP INDEX` uses `ON <table>`, every file has rollback

---

## Common Drizzle Kit Patterns to Recognise

| Pattern | What It Is | How to Handle |
|---------|-----------|---------------|
| `--> statement-breakpoint` | Drizzle Kit's statement separator | **Remove** from output |
| `` CREATE TABLE `x` (...) `` | Table creation with backticks | Add `IF NOT EXISTS` |
| `` enum('a','b','c') `` | Inline enum type in column | Keep as-is (no wrapping) |
| `serial AUTO_INCREMENT` | Auto-incrementing integer | Keep as-is |
| `bigint unsigned` | FK reference column type | Keep as-is |
| `` ALTER TABLE `x` ADD CONSTRAINT ... FOREIGN KEY `` | Standalone FK | Keep as-is (do NOT wrap) |
| `` MODIFY COLUMN `c` <type> `` | Column type change | Keep as-is; rollback needs manual entry |
| `` ADD `c` <type> `` | Add column (no COLUMN keyword) | Keep as-is (no `IF NOT EXISTS`) |
| `decimal(p,s)` | Exact numeric type | Keep as-is |

---

## Edge Cases

1. **Empty migration file**: Skip it — don't create an empty Liquibase file.
2. **Comments in input**: Preserve SQL comments (`-- comment`). Don't confuse them with Liquibase directives.
3. **Multiline statements**: Keep the original formatting. Ensure each statement ends with `;` followed by a blank line.
4. **Already idempotent SQL**: If input already has `IF NOT EXISTS` / `IF EXISTS`, don't duplicate it.
5. **Drizzle Kit metadata comments**: Lines like `-- Custom SQL migration file` can be removed or kept — they're harmless.
6. **MySQL `DROP INDEX` syntax**: Always include `ON <table>` in MySQL `DROP INDEX` rollbacks — MySQL requires it, unlike PostgreSQL and SQLite.

---

## Other Liquibase Changelog Formats

This guide focuses on **Formatted SQL** because it's the most natural fit for Drizzle Kit migrations
(SQL in → SQL out). However, Liquibase supports **four changelog formats**:

| Format | Extension | Best For |
|--------|-----------|----------|
| **SQL** | `.sql` | Direct SQL migrations (what this guide produces) |
| **XML** | `.xml` | Full Liquibase feature set, cross-database portability |
| **YAML** | `.yaml` | Human-readable alternative to XML |
| **JSON** | `.json` | Programmatic generation / CI pipelines |

All four formats support the same features (changesets, rollbacks, preconditions, contexts, labels).
The master changelog (`master-changelog.xml`) can include files of **any** format — you can mix
SQL migration files with XML/YAML/JSON changelogs in the same project.

For full details on each format, see the [Liquibase Changelog documentation](https://docs.liquibase.com/concepts/changelogs/home.html).

---

## Liquibase Documentation References

- **Formatted SQL changelogs**: https://docs.liquibase.com/concepts/changelogs/sql-format.html
- **Changelog formats (XML, YAML, JSON, SQL)**: https://docs.liquibase.com/concepts/changelogs/home.html
- **Rollback workflows**: https://docs.liquibase.com/workflows/liquibase-community/using-rollback.html
- **`rollbackSqlFile` (Pro)**: https://docs.liquibase.com/concepts/changelogs/sql-format.html#rollbackSqlFile
- **`sqlFile` Change Type**: https://docs.liquibase.com/change-types/sql-file.html
- **Changeset attributes**: https://docs.liquibase.com/concepts/changelogs/sql-format.html#changeset
- **Preconditions**: https://docs.liquibase.com/concepts/changelogs/preconditions.html
- **Supported databases**: https://www.liquibase.org/get-started/databases
