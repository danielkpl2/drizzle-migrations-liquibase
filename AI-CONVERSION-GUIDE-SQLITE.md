# AI Migration Conversion Guide — SQLite

> **For AI models**: This file contains the complete rules and examples needed to convert
> Drizzle Kit **SQLite** migrations into Liquibase-formatted SQL. Follow these rules exactly.
> Every rule is mandatory unless explicitly marked as optional.

---

## Task

You are converting **Drizzle Kit** SQLite migration files (generated by `drizzle-kit generate`)
into **Liquibase Formatted SQL** files compatible with `drizzle-migrations-liquibase`.

**Input**: One or more Drizzle Kit `.sql` migration files (e.g. `0001_cool_name.sql`)
**Output**: Liquibase-formatted `.sql` files with rollback support
**Dialect**: SQLite — identifiers use backticks (`` `users` ``, `` `id` ``), types are `integer`, `text`, `real`

---

## Output File Template

Every output file MUST follow this exact structure:

```sql
--liquibase formatted sql

--changeset <author>:<changeset_id>

<statement 1>;

<statement 2>;

--rollback <rollback for statement 2>;
--rollback <rollback for statement 1>;
```

---

## Rules

### Rule 1: File Header

The **very first line** must be:
```
--liquibase formatted sql
```
No blank lines or comments before it.

### Rule 2: Changeset Declaration

After one blank line, add:
```
--changeset <author>:<changeset_id>
```

- **`<author>`**: The git email, username, or configured author name. If unknown, use `migration`.
- **`<changeset_id>`**: A **descriptive** snake_case name summarising the migration's SQL content.
  Drizzle Kit auto-generates opaque or random names (e.g. `cool_name`, `mighty_blob`, `shiny_wasp`).
  **Do NOT use these.** Instead, read the SQL statements and derive a meaningful name:
  - `0001_cool_name.sql` containing `` CREATE TABLE `users` `` → `create_users_table`
  - `0003_mighty_blob.sql` containing `` ADD `phone` `` + `` ADD `avatar_url` `` on `` `users` `` → `add_phone_and_avatar_to_users`
  - `0042_add_user_roles.sql` → `add_user_roles` (already descriptive — keep as-is)

**Do NOT add** `splitStatements:false` or `endDelimiter` — SQLite statements all terminate with `;` and have no compound blocks, so Liquibase's default splitting works correctly.

### Rule 3: Strip Drizzle Kit Statement Breakpoints

Drizzle Kit input files contain `--> statement-breakpoint` separators between statements.
**Remove these entirely** — they are not needed in the output. Liquibase splits SQLite
changesets on `;` by default, which is correct for all SQLite statements.

Separate statements with a blank line for readability.

### Rule 4: Idempotent DDL

Transform these DDL statements to be idempotent:

| Original | Converted |
|----------|-----------|
| `` CREATE TABLE `x` ( `` | `` CREATE TABLE IF NOT EXISTS `x` ( `` |
| `` DROP TABLE `x` `` | `` DROP TABLE IF EXISTS `x` `` |
| `` CREATE INDEX `i` ON `` | `` CREATE INDEX IF NOT EXISTS `i` ON `` |
| `` DROP INDEX `i` `` | `` DROP INDEX IF EXISTS `i` `` |
| `` CREATE UNIQUE INDEX `i` ON `` | `` CREATE UNIQUE INDEX IF NOT EXISTS `i` ON `` |

SQLite has very limited `ALTER TABLE` support: only `ADD COLUMN` (and `DROP COLUMN` in SQLite 3.35+, no `ALTER COLUMN`). Drizzle Kit handles complex changes by recreating tables. Leave all `ALTER TABLE` statements as-is — no `IF NOT EXISTS` on `ADD COLUMN`.

### Rule 5: Foreign Key Handling

SQLite foreign keys are always **inline** within `CREATE TABLE`:
```sql
CREATE TABLE `orders` (
	`id` integer PRIMARY KEY AUTOINCREMENT NOT NULL,
	`user_id` integer NOT NULL,
	FOREIGN KEY (`user_id`) REFERENCES `users`(`id`) ON UPDATE no action ON DELETE no action
);
```

**No wrapping needed** — they're part of the `CREATE TABLE` statement and get handled by `IF NOT EXISTS` on the table itself.

**Never** try to extract inline `FOREIGN KEY` clauses into standalone `ALTER TABLE` statements — SQLite doesn't support that syntax.

### Rule 6: Rollback Block

After all forward statements, add rollback lines. Rules:

1. Every `--rollback` line is a SQL comment — prefix each line with `--rollback `.
2. Rollback statements are in **reverse order** of the forward statements.
3. Each rollback statement is a separate `--rollback` line ending with `;`.

#### Rollback mappings

| Forward Statement | Rollback Statement |
|-------------------|--------------------|
| `` CREATE TABLE IF NOT EXISTS `x` (...) `` | `` DROP TABLE IF EXISTS `x`; `` |
| `` DROP TABLE IF EXISTS `x` `` | `-- WARNING: Cannot rollback DROP TABLE for x` |
| `` ADD `c` <type> `` | `-- WARNING: SQLite cannot DROP COLUMN before 3.35` |
| `` CREATE INDEX IF NOT EXISTS `i` `` | `` DROP INDEX IF EXISTS `i`; `` |
| `` DROP INDEX IF EXISTS `i` `` | `-- WARNING: Cannot rollback index drop i` |
| `INSERT INTO ...` | `DELETE FROM ... WHERE ...;` (match the inserted row) |
| `UPDATE ... SET ...` | `-- WARNING: Cannot reliably rollback UPDATE` |

**SQLite rollback notes:**
- SQLite has very limited `ALTER TABLE` — `DROP COLUMN` only works in SQLite 3.35+ (2021). For broader compatibility, use a warning comment.
- Foreign keys are inline in `CREATE TABLE`, so dropping the table handles FK rollback.
- No `ALTER COLUMN`, `DROP CONSTRAINT`, or `MODIFY COLUMN` support — these never appear in SQLite migrations.

### Rule 7: Filename

Rename the file:
```
<timestamp>_<original_name>.sql
```

- **Timestamp**: `YYYYMMDDHHmmss` format using the current date/time. If converting a batch, increment by 1 second per file to maintain order.
- **Descriptive name**: Drizzle Kit often generates random/opaque names (`cool_name`, `mighty_blob`, `shiny_wasp`).
  **Replace these with a descriptive snake_case name** derived from the SQL content of the migration.
  If the original name is already descriptive, keep it.
  - `0001_cool_name.sql` (creates `users` table) → `20250710092120_create_users_table.sql`
  - `0003_mighty_blob.sql` (adds columns to `users`) → `20250710092122_add_phone_and_avatar_to_users.sql`
  - `0042_add_user_roles.sql` (already descriptive) → `20250710092121_add_user_roles.sql`

  **Naming heuristics** (in priority order):
  1. `` CREATE TABLE `x` `` → `create_x_table`
  2. `` ADD `column` `` on `` `x` `` → `add_<columns>_to_x`
  3. `` DROP TABLE `x` `` → `drop_x_table`
  4. `CREATE INDEX` → `add_indexes_to_x`
  5. Mixed operations → pick the most significant operation for the name
  6. If the original Drizzle Kit name is already descriptive (contains a verb + noun), keep it

### Rule 8: One Changeset Per File (Default)

Each output file should contain **one `--changeset` block** unless the input file logically groups
related operations (e.g. table creation + its indexes). In that case, use one changeset
for the whole file.

**Never split a single Drizzle Kit migration across multiple output files.**

### Rule 9: Master Changelog

After converting all files, provide the `master-changelog.xml` with includes in chronological order:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<databaseChangeLog
    xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog
        http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-4.20.xsd">

    <include file="migrations/<filename1>.sql"/>
    <include file="migrations/<filename2>.sql"/>
    <!-- ... one per file, in timestamp order -->
</databaseChangeLog>
```

### Rule 10: Remove Drizzle Kit Statement Breakpoints

Drizzle Kit input files use `--> statement-breakpoint` as a statement separator.
**Remove all occurrences** from the output — Liquibase uses `;` as the default
statement delimiter for SQLite, which is sufficient.

---

## Complete Conversion Examples

### Example 1: CREATE TABLE + Index

**Input** (`0001_initial.sql`):
```sql
CREATE TABLE `users` (
	`id` integer PRIMARY KEY AUTOINCREMENT NOT NULL,
	`email` text NOT NULL,
	`name` text(100),
	`role` text DEFAULT 'member' NOT NULL,
	`is_active` integer DEFAULT true NOT NULL,
	`created_at` integer DEFAULT (unixepoch()) NOT NULL
);
--> statement-breakpoint
CREATE UNIQUE INDEX `users_email_unique` ON `users` (`email`);
--> statement-breakpoint
CREATE INDEX `users_email_idx` ON `users` (`email`);
--> statement-breakpoint
CREATE TABLE `orders` (
	`id` integer PRIMARY KEY AUTOINCREMENT NOT NULL,
	`user_id` integer NOT NULL,
	`total_amount` real NOT NULL,
	`created_at` integer DEFAULT (unixepoch()) NOT NULL,
	FOREIGN KEY (`user_id`) REFERENCES `users`(`id`) ON UPDATE no action ON DELETE no action
);
--> statement-breakpoint
CREATE INDEX `orders_user_id_idx` ON `orders` (`user_id`);
```

**Output** (`20250710092120_initial.sql`):
```sql
--liquibase formatted sql

--changeset migration:initial

CREATE TABLE IF NOT EXISTS `users` (
	`id` integer PRIMARY KEY AUTOINCREMENT NOT NULL,
	`email` text NOT NULL,
	`name` text(100),
	`role` text DEFAULT 'member' NOT NULL,
	`is_active` integer DEFAULT true NOT NULL,
	`created_at` integer DEFAULT (unixepoch()) NOT NULL
);

CREATE UNIQUE INDEX IF NOT EXISTS `users_email_unique` ON `users` (`email`);

CREATE INDEX IF NOT EXISTS `users_email_idx` ON `users` (`email`);

CREATE TABLE IF NOT EXISTS `orders` (
	`id` integer PRIMARY KEY AUTOINCREMENT NOT NULL,
	`user_id` integer NOT NULL,
	`total_amount` real NOT NULL,
	`created_at` integer DEFAULT (unixepoch()) NOT NULL,
	FOREIGN KEY (`user_id`) REFERENCES `users`(`id`) ON UPDATE no action ON DELETE no action
);

CREATE INDEX IF NOT EXISTS `orders_user_id_idx` ON `orders` (`user_id`);

--rollback DROP INDEX IF EXISTS `orders_user_id_idx`;
--rollback DROP TABLE IF EXISTS `orders`;
--rollback DROP INDEX IF EXISTS `users_email_idx`;
--rollback DROP INDEX IF EXISTS `users_email_unique`;
--rollback DROP TABLE IF EXISTS `users`;
```

**Key points:**
- Uses `integer`, `text`, `real` types — no `varchar`, `decimal`, `uuid`
- `integer PRIMARY KEY AUTOINCREMENT` instead of `serial` or `uuid`
- Times stored as `integer` with `unixepoch()` instead of `timestamp` with `now()`
- Foreign keys are **inline** within `CREATE TABLE` — no standalone `ALTER TABLE ... ADD CONSTRAINT`
- Boolean stored as `integer` with `DEFAULT true/false`
- Indexes support `IF NOT EXISTS`

### Example 2: ADD COLUMN + INDEX

**Input** (`0005_add_fields.sql`):
```sql
ALTER TABLE `users` ADD `phone` text(20);
--> statement-breakpoint
ALTER TABLE `users` ADD `avatar_url` text(500);
--> statement-breakpoint
ALTER TABLE `products` ADD `discount` real DEFAULT 0;
--> statement-breakpoint
CREATE INDEX `products_name_status_idx` ON `products` (`name`,`status`);
```

**Output** (`20250710092121_add_fields.sql`):
```sql
--liquibase formatted sql

--changeset migration:add_fields

ALTER TABLE `users` ADD `phone` text(20);

ALTER TABLE `users` ADD `avatar_url` text(500);

ALTER TABLE `products` ADD `discount` real DEFAULT 0;

CREATE INDEX IF NOT EXISTS `products_name_status_idx` ON `products` (`name`,`status`);

--rollback DROP INDEX IF EXISTS `products_name_status_idx`;
--rollback -- WARNING: SQLite cannot DROP COLUMN before 3.35 — ALTER TABLE `products` DROP COLUMN `discount`;
--rollback -- WARNING: SQLite cannot DROP COLUMN before 3.35 — ALTER TABLE `users` DROP COLUMN `avatar_url`;
--rollback -- WARNING: SQLite cannot DROP COLUMN before 3.35 — ALTER TABLE `users` DROP COLUMN `phone`;
```

**Key points:**
- SQLite uses `ADD <col>` without `COLUMN` keyword
- No `IF NOT EXISTS` on `ADD COLUMN`
- Rollback for `ADD COLUMN` uses a warning because `DROP COLUMN` requires SQLite 3.35+
- `text(20)` is valid SQLite syntax (length is advisory, not enforced)

---

## Batch Conversion Checklist

When converting multiple Drizzle Kit migration files at once:

1. Sort input files by their numeric prefix (`0001`, `0002`, ...)
2. Assign incrementing timestamps to output files (maintain original order)
3. Convert each file independently using the rules above
4. Generate `master-changelog.xml` with all files in timestamp order
5. Verify: `CREATE TABLE` and indexes have `IF [NOT] EXISTS`, foreign keys are inline, no standalone FK statements, every file has rollback

---

## Common Drizzle Kit Patterns to Recognise

| Pattern | What It Is | How to Handle |
|---------|-----------|---------------|
| `--> statement-breakpoint` | Drizzle Kit's statement separator | **Remove** from output |
| `` CREATE TABLE `x` (...) `` | Table creation with backticks | Add `IF NOT EXISTS` |
| `integer PRIMARY KEY AUTOINCREMENT` | Auto-incrementing PK | Keep as-is |
| `` FOREIGN KEY (`c`) REFERENCES `t`(`id`) `` | Inline FK in CREATE TABLE | Keep as-is (part of CREATE TABLE) |
| `text`, `integer`, `real` | SQLite type affinity | Keep as-is |
| `text(N)` | Text with advisory length | Keep as-is (length not enforced) |
| `unixepoch()` | Unix timestamp default | Keep as-is |
| `DEFAULT true` / `DEFAULT false` | Boolean as integer | Keep as-is |
| `` ADD `c` <type> `` | Add column (limited ALTER TABLE) | Keep as-is; rollback may need warning |

---

## Edge Cases

1. **Empty migration file**: Skip it — don't create an empty Liquibase file.
2. **Comments in input**: Preserve SQL comments (`-- comment`). Don't confuse them with Liquibase directives.
3. **Multiline statements**: Keep the original formatting. Ensure each statement ends with `;` followed by a blank line.
4. **Already idempotent SQL**: If input already has `IF NOT EXISTS` / `IF EXISTS`, don't duplicate it.
5. **Drizzle Kit metadata comments**: Lines like `-- Custom SQL migration file` can be removed or kept — they're harmless.
6. **SQLite table recreation**: Drizzle Kit sometimes generates `CREATE TABLE ... AS SELECT` + `DROP TABLE` + `ALTER TABLE ... RENAME` sequences for complex schema changes. Preserve these as-is — they're SQLite's workaround for missing `ALTER COLUMN` support.
7. **SQLite inline foreign keys**: Never try to extract inline `FOREIGN KEY` clauses into standalone `ALTER TABLE` statements — SQLite doesn't support that syntax.

---

## Other Liquibase Changelog Formats

This guide focuses on **Formatted SQL** because it's the most natural fit for Drizzle Kit migrations
(SQL in → SQL out). However, Liquibase supports **four changelog formats**:

| Format | Extension | Best For |
|--------|-----------|----------|
| **SQL** | `.sql` | Direct SQL migrations (what this guide produces) |
| **XML** | `.xml` | Full Liquibase feature set, cross-database portability |
| **YAML** | `.yaml` | Human-readable alternative to XML |
| **JSON** | `.json` | Programmatic generation / CI pipelines |

All four formats support the same features (changesets, rollbacks, preconditions, contexts, labels).
The master changelog (`master-changelog.xml`) can include files of **any** format — you can mix
SQL migration files with XML/YAML/JSON changelogs in the same project.

For full details on each format, see the [Liquibase Changelog documentation](https://docs.liquibase.com/concepts/changelogs/home.html).

---

## Liquibase Documentation References

- **Formatted SQL changelogs**: https://docs.liquibase.com/concepts/changelogs/sql-format.html
- **Changelog formats (XML, YAML, JSON, SQL)**: https://docs.liquibase.com/concepts/changelogs/home.html
- **Rollback workflows**: https://docs.liquibase.com/workflows/liquibase-community/using-rollback.html
- **`rollbackSqlFile` (Pro)**: https://docs.liquibase.com/concepts/changelogs/sql-format.html#rollbackSqlFile
- **`sqlFile` Change Type**: https://docs.liquibase.com/change-types/sql-file.html
- **Changeset attributes**: https://docs.liquibase.com/concepts/changelogs/sql-format.html#changeset
- **Preconditions**: https://docs.liquibase.com/concepts/changelogs/preconditions.html
- **Supported databases**: https://www.liquibase.org/get-started/databases
