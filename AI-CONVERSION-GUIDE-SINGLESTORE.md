# AI Migration Conversion Guide — SingleStore

> **For AI models**: This file contains the rules needed to convert
> Drizzle Kit **SingleStore** migrations into Liquibase-formatted SQL. Follow these rules exactly.

---

## Task

You are converting **Drizzle Kit** SingleStore migration files (generated by `drizzle-kit generate`)
into **Liquibase Formatted SQL** files compatible with `drizzle-migrations-liquibase`.

**Input**: One or more Drizzle Kit `.sql` migration files (e.g. `0001_cool_name.sql`)
**Output**: Liquibase-formatted `.sql` files with rollback support
**Dialect**: SingleStore — uses MySQL wire protocol, backtick identifiers (`` `users` ``, `` `id` ``)

SingleStore users will already have migrations tuned for SingleStore's constraints (no FKs, no secondary indexes on columnstore, etc.). **Do not modify the forward SQL** beyond what these rules require. Focus on correct Liquibase formatting and rollback generation.

---

## Output File Template

Every output file MUST follow this exact structure:

```sql
--liquibase formatted sql

--changeset <author>:<changeset_id>

<statement 1>;

<statement 2>;

--rollback <rollback for statement 2>;
--rollback <rollback for statement 1>;
```

---

## Rules

### Rule 1: File Header

The **very first line** must be:
```
--liquibase formatted sql
```
No blank lines or comments before it.

### Rule 2: Changeset Declaration

After one blank line, add:
```
--changeset <author>:<changeset_id>
```

- **`<author>`**: The git email, username, or configured author name. If unknown, use `migration`.
- **`<changeset_id>`**: A **descriptive** snake_case name summarising the migration's SQL content.
  Drizzle Kit auto-generates opaque or random names (e.g. `cool_name`, `mighty_blob`).
  **Do NOT use these.** Read the SQL statements and derive a meaningful name.

**Do NOT add** `splitStatements:false` or `endDelimiter` — SingleStore uses MySQL-style `;` terminators, so Liquibase's default splitting works correctly.

### Rule 3: Strip Drizzle Kit Statement Breakpoints

Remove all `--> statement-breakpoint` separators from the output. Separate statements with a blank line for readability.

### Rule 4: Idempotent DDL

Only transform these:

| Original | Converted |
|----------|-----------|
| `` CREATE TABLE `x` ( `` | `` CREATE TABLE IF NOT EXISTS `x` ( `` |
| `` DROP TABLE `x` `` | `` DROP TABLE IF EXISTS `x` `` |

**Leave all other DDL as-is** — SingleStore/MySQL has limited `IF [NOT] EXISTS` support.

### Rule 5: Rollback Block

After all forward statements, add rollback lines in **reverse order**. Each `--rollback` line is a SQL comment ending with `;`.

#### Standard Rollback Mappings

| Forward Statement | Rollback Statement |
|-------------------|--------------------|
| `` CREATE TABLE IF NOT EXISTS `x` (...) `` | `` DROP TABLE IF EXISTS `x`; `` |
| `` DROP TABLE IF EXISTS `x` `` | `-- WARNING: Cannot rollback DROP TABLE for x` |
| `` ADD `c` <type> `` | `` ALTER TABLE `x` DROP COLUMN `c`; `` |
| `` DROP COLUMN `c` `` | `-- WARNING: Cannot rollback DROP COLUMN for x.c` |
| `` MODIFY COLUMN `c` <new_type> `` | `-- Manual rollback required: revert MODIFY COLUMN change on x.c;` |
| `` CREATE INDEX `i` ON `t` `` | `` DROP INDEX `i` ON `t`; `` |
| `` ALTER TABLE `x` RENAME TO `y` `` | `` ALTER TABLE `y` RENAME TO `x`; `` |

### Rule 6: Copy-to-New-Table Rollback (SingleStore-specific)

**This is the most important rule.** Drizzle Kit uses a "copy to new table" strategy for SingleStore schema changes instead of `ALTER TABLE ADD COLUMN`:

```sql
CREATE TABLE `__new_users` (...);                               -- 1. new schema
INSERT INTO `__new_users`(...) SELECT ... FROM `users`;         -- 2. copy data
DROP TABLE `users`;                                             -- 3. drop old
ALTER TABLE `__new_users` RENAME TO `users`;                    -- 4. rename
```

**How to recognise this pattern:**
- The migration creates a table named `` `__new_<tablename>` ``
- Followed by `INSERT INTO` ... `SELECT` ... `FROM` the original table
- Followed by `DROP TABLE` of the original
- Followed by `RENAME TO` the original name

When you see this 4-statement group, treat it as **one logical unit** and generate a single rollback block for the group.

#### Deriving the old table schema from the migration

The migration contains everything you need:

1. **New column definitions** — the `CREATE TABLE __new_<table>` statement has complete column definitions (types, constraints, defaults)
2. **Old column list** — the `SELECT` side of the `INSERT INTO ... SELECT` lists the columns that existed in the original table

**To reconstruct the old table**: take the column definitions from the `CREATE TABLE __new_<table>`, and keep only the columns that appear in the `SELECT` clause. The columns NOT in the `SELECT` are the newly-added ones — exclude those.

#### Rollback pattern

```sql
--rollback ALTER TABLE `<table>` RENAME TO `__rollback_<table>`;
--rollback CREATE TABLE IF NOT EXISTS `<table>` (<old column definitions + constraints>);
--rollback INSERT INTO `<table>`(<old cols>) SELECT <old cols> FROM `__rollback_<table>`;
--rollback DROP TABLE IF EXISTS `__rollback_<table>`;
```

**Step by step:**
1. Rename the current table (which has the NEW schema) to a temp name
2. Recreate the table with the OLD schema (derived as described above)
3. Copy data back — only the old columns (new columns are discarded)
4. Drop the temp table

#### Worked example

Given this forward migration:

```sql
CREATE TABLE `__new_users` (
	`id` bigint unsigned AUTO_INCREMENT NOT NULL,
	`email` varchar(255) NOT NULL,
	`name` varchar(100),
	`phone` varchar(20),
	`role` enum('admin','member','guest') NOT NULL DEFAULT 'member',
	`created_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
	CONSTRAINT `users_id` PRIMARY KEY(`id`)
);

INSERT INTO `__new_users`(`id`, `email`, `name`, `role`, `created_at`)
  SELECT `id`, `email`, `name`, `role`, `created_at` FROM `users`;

DROP TABLE `users`;

ALTER TABLE `__new_users` RENAME TO `users`;
```

The SELECT lists: `id`, `email`, `name`, `role`, `created_at` — these are the OLD columns.
The `__new_users` table adds `phone` — which is NOT in the SELECT, so it's new.

Rollback:

```sql
--rollback ALTER TABLE `users` RENAME TO `__rollback_users`;
--rollback CREATE TABLE IF NOT EXISTS `users` (
--rollback 	`id` bigint unsigned AUTO_INCREMENT NOT NULL,
--rollback 	`email` varchar(255) NOT NULL,
--rollback 	`name` varchar(100),
--rollback 	`role` enum('admin','member','guest') NOT NULL DEFAULT 'member',
--rollback 	`created_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
--rollback 	CONSTRAINT `users_id` PRIMARY KEY(`id`)
--rollback );
--rollback INSERT INTO `users`(`id`, `email`, `name`, `role`, `created_at`) SELECT `id`, `email`, `name`, `role`, `created_at` FROM `__rollback_users`;
--rollback DROP TABLE IF EXISTS `__rollback_users`;
```

#### Edge cases requiring manual review

While the rollback can be derived automatically in most cases, **review carefully** when:

- **Column types were changed** (not just added/removed) — the SELECT may list the same column name but the type in `__new_<table>` is the new type, not the old one. The rollback would recreate it with the new type. Flag with a `-- NOTE:` comment.
- **Column defaults were changed** — same issue; the CREATE TABLE has the new defaults.
- **Columns were removed** — they appear in the SELECT but NOT in `__new_<table>`. You cannot derive their type from this migration alone. Flag as manual.
- **Multiple copy-to-new-table groups in one migration** — each is independent; generate separate rollback blocks for each, in reverse order.

### Rule 7: Filename

Rename the file:
```
<timestamp>_<descriptive_name>.sql
```

- **Timestamp**: `YYYYMMDDHHmmss` format. If converting a batch, increment by 1 second per file.
- **Descriptive name**: Replace Drizzle Kit's random names with snake_case derived from the SQL content.

### Rule 8: One Changeset Per File

Each output file should contain **one `--changeset` block**. Never split a single Drizzle Kit migration across multiple output files.

### Rule 9: Master Changelog

After converting all files, provide the `master-changelog.xml`:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<databaseChangeLog
    xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog
        http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-4.20.xsd">

    <include file="migrations/<filename1>.sql"/>
    <include file="migrations/<filename2>.sql"/>
</databaseChangeLog>
```

---

## Complete Conversion Examples

### Example 1: Initial Table Creation

**Input** (`0001_initial.sql`):
```sql
CREATE TABLE `users` (
	`id` bigint unsigned AUTO_INCREMENT NOT NULL,
	`email` varchar(255) NOT NULL,
	`name` varchar(100),
	`role` enum('admin','member','guest') NOT NULL DEFAULT 'member',
	`is_active` boolean NOT NULL DEFAULT true,
	`created_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
	CONSTRAINT `users_id` PRIMARY KEY(`id`)
);
--> statement-breakpoint
CREATE TABLE `orders` (
	`id` bigint unsigned AUTO_INCREMENT NOT NULL,
	`user_id` bigint unsigned NOT NULL,
	`total_amount` decimal(10,2) NOT NULL,
	`status` enum('pending','processing','shipped') NOT NULL DEFAULT 'pending',
	`created_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
	CONSTRAINT `orders_id` PRIMARY KEY(`id`)
);
```

**Output** (`20250710092120_create_users_and_orders.sql`):
```sql
--liquibase formatted sql

--changeset migration:create_users_and_orders

CREATE TABLE IF NOT EXISTS `users` (
	`id` bigint unsigned AUTO_INCREMENT NOT NULL,
	`email` varchar(255) NOT NULL,
	`name` varchar(100),
	`role` enum('admin','member','guest') NOT NULL DEFAULT 'member',
	`is_active` boolean NOT NULL DEFAULT true,
	`created_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
	CONSTRAINT `users_id` PRIMARY KEY(`id`)
);

CREATE TABLE IF NOT EXISTS `orders` (
	`id` bigint unsigned AUTO_INCREMENT NOT NULL,
	`user_id` bigint unsigned NOT NULL,
	`total_amount` decimal(10,2) NOT NULL,
	`status` enum('pending','processing','shipped') NOT NULL DEFAULT 'pending',
	`created_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
	CONSTRAINT `orders_id` PRIMARY KEY(`id`)
);

--rollback DROP TABLE IF EXISTS `orders`;
--rollback DROP TABLE IF EXISTS `users`;
```

**Key points:**
- No foreign keys (SingleStore doesn't support them)
- No indexes (columnstore doesn't support secondary indexes)
- `bigint unsigned AUTO_INCREMENT` instead of `serial`
- Enums are inline column types — no `CREATE TYPE`

### Example 2: Copy-to-New-Table Migration (Schema Change)

**Input** (`0002_add_fields.sql`):
```sql
CREATE TABLE `coupons` (
	`id` bigint unsigned AUTO_INCREMENT NOT NULL,
	`code` varchar(50) NOT NULL,
	`discount_type` enum('percentage','fixed_amount') NOT NULL,
	`discount_value` decimal(10,2) NOT NULL,
	`is_active` boolean NOT NULL DEFAULT true,
	`created_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
	CONSTRAINT `coupons_id` PRIMARY KEY(`id`)
);
--> statement-breakpoint
CREATE TABLE `__new_users` (
	`id` bigint unsigned AUTO_INCREMENT NOT NULL,
	`email` varchar(255) NOT NULL,
	`name` varchar(100),
	`phone` varchar(20),
	`role` enum('admin','member','guest') NOT NULL DEFAULT 'member',
	`is_active` boolean NOT NULL DEFAULT true,
	`created_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
	CONSTRAINT `users_id` PRIMARY KEY(`id`)
);
--> statement-breakpoint
INSERT INTO `__new_users`(`id`, `email`, `name`, `role`, `is_active`, `created_at`) SELECT `id`, `email`, `name`, `role`, `is_active`, `created_at` FROM `users`;
--> statement-breakpoint
DROP TABLE `users`;
--> statement-breakpoint
ALTER TABLE `__new_users` RENAME TO `users`;
```

**Output** (`20250710092121_add_coupons_and_phone_to_users.sql`):
```sql
--liquibase formatted sql

--changeset migration:add_coupons_and_phone_to_users

CREATE TABLE IF NOT EXISTS `coupons` (
	`id` bigint unsigned AUTO_INCREMENT NOT NULL,
	`code` varchar(50) NOT NULL,
	`discount_type` enum('percentage','fixed_amount') NOT NULL,
	`discount_value` decimal(10,2) NOT NULL,
	`is_active` boolean NOT NULL DEFAULT true,
	`created_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
	CONSTRAINT `coupons_id` PRIMARY KEY(`id`)
);

CREATE TABLE `__new_users` (
	`id` bigint unsigned AUTO_INCREMENT NOT NULL,
	`email` varchar(255) NOT NULL,
	`name` varchar(100),
	`phone` varchar(20),
	`role` enum('admin','member','guest') NOT NULL DEFAULT 'member',
	`is_active` boolean NOT NULL DEFAULT true,
	`created_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
	CONSTRAINT `users_id` PRIMARY KEY(`id`)
);

INSERT INTO `__new_users`(`id`, `email`, `name`, `role`, `is_active`, `created_at`) SELECT `id`, `email`, `name`, `role`, `is_active`, `created_at` FROM `users`;

DROP TABLE `users`;

ALTER TABLE `__new_users` RENAME TO `users`;

--rollback ALTER TABLE `users` RENAME TO `__rollback_users`;
--rollback CREATE TABLE IF NOT EXISTS `users` (
--rollback 	`id` bigint unsigned AUTO_INCREMENT NOT NULL,
--rollback 	`email` varchar(255) NOT NULL,
--rollback 	`name` varchar(100),
--rollback 	`role` enum('admin','member','guest') NOT NULL DEFAULT 'member',
--rollback 	`is_active` boolean NOT NULL DEFAULT true,
--rollback 	`created_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
--rollback 	CONSTRAINT `users_id` PRIMARY KEY(`id`)
--rollback );
--rollback INSERT INTO `users`(`id`, `email`, `name`, `role`, `is_active`, `created_at`) SELECT `id`, `email`, `name`, `role`, `is_active`, `created_at` FROM `__rollback_users`;
--rollback DROP TABLE IF EXISTS `__rollback_users`;
--rollback DROP TABLE IF EXISTS `coupons`;
```

**Key points:**
- The `__new_users` → `DROP` → `RENAME` group gets a derived rollback that reconstructs the old table
- Old columns identified from the `SELECT` clause: `id`, `email`, `name`, `role`, `is_active`, `created_at`
- Column `phone` is NOT in the SELECT → it was newly added → excluded from rollback table
- Column definitions taken from `__new_users` CREATE TABLE, filtered to old columns only
- Do NOT add `IF NOT EXISTS` to `__new_users` — it's a temporary table that must not already exist
- The `coupons` table gets a normal `DROP TABLE` rollback
- Rollback order: users rollback (last applied) before coupons rollback (first applied)

---

## Common Drizzle Kit SingleStore Patterns

| Pattern | What It Is | How to Handle |
|---------|-----------|---------------|
| `--> statement-breakpoint` | Statement separator | **Remove** from output |
| `` CREATE TABLE `x` (...) `` | Table creation | Add `IF NOT EXISTS` |
| `` CREATE TABLE `__new_x` (...) `` | Copy-to-new-table step 1 | Keep as-is (no `IF NOT EXISTS`) |
| `` INSERT INTO `__new_x` ... SELECT ... FROM `x` `` | Data copy step | Keep as-is; review column list |
| `` DROP TABLE `x` `` | Old table removal | Add `IF EXISTS` |
| `` ALTER TABLE `__new_x` RENAME TO `x` `` | Final rename step | Keep as-is |
| `bigint unsigned AUTO_INCREMENT` | Primary key column | Keep as-is (not `serial`) |
| `` enum('a','b','c') `` | Inline enum type | Keep as-is (no `CREATE TYPE`) |

---

## Edge Cases

1. **Copy-to-new-table INSERT column mismatch**: drizzle-kit may generate `INSERT...SELECT` that references columns not in the original table. If you see this, fix the column lists manually before converting.
2. **Multiple copy-to-new-table groups**: Each `__new_<table>` group is independent. Generate separate rollback comment blocks for each.
3. **Free tier table limits**: SingleStore Helios free tier limits ~10 tables. The `__new_` tables are temporary but count toward the limit during migration.
4. **Empty migration file**: Skip it — don't create an empty Liquibase file.
5. **`DROP INDEX` syntax**: Same as MySQL — always include `ON <table>`, e.g. `` DROP INDEX `idx` ON `users`; ``

---

## Liquibase Documentation References

- **Formatted SQL changelogs**: https://docs.liquibase.com/concepts/changelogs/sql-format.html
- **Rollback workflows**: https://docs.liquibase.com/workflows/liquibase-community/using-rollback.html
- **Changeset attributes**: https://docs.liquibase.com/concepts/changelogs/sql-format.html#changeset
- **Supported databases**: https://www.liquibase.org/get-started/databases
